---
layout: post
title: 日志那些事儿（命题作文 :-) ）
categories: [Sharing]
tags: [Career, Logging]
fullview: false
comments: true
---


# 日志的目的

凡事都是有目的的，日志也不例外。根据我知道的情况，日志有下面几个目的：

* 调试程序，尤其是没有办法设置断点单步跟踪的地方，`printf`大法是终极招数。这种日志一般是不会进入产品的东西，Code Review应该能够拦下。
* 记录行为，所谓的telemetry。数据上来以后进行统计分析，用来理解用户行为，为今后用户体验设计提供输入。
* 记录运行情况，live site issue调试的主要依据。
* 记录系统状态，主要是heart beat，内存，CPU情况等，会有其他的runner盯着这些数据，进入异常状态的时候会报警。
* 记录数据库中数据的变化，这个比较特殊，可以用来恢复数据

# 日志的收集和查询

看日志产生的位置，决定了日志的收集方式。

* 设备或者操作系统日志，一般就在这个设备的存储器上，满了就循环覆盖。除非有专门的服务盯着日志数据并且负责打包上传的某服务器，否则我们只能通过直接连接设备看到最近一段时间的日志。
* 应用程序日志，现在的应用程序一般都会上传自己的日志到自家的服务器去。3Q大战我记得就是从日志打响的，互相分析日志，看对方上传了什么。于是得出结论，应用程序离线日志的加密是很重要的。Linux系统上
* 系统日志，Windows的日志系统很完善，二进制日志的体积很小。日志过滤略微差点儿意思，但大部分时候够用。实在不行还可以导出了用别的软件分析。Linux则是放在`/var/log`下面的文本文件，直接sed+awk就能看，各有千秋。
* 网络服务日志，一般是所有日志都会上传到一个microservice，这个microservice把数据收集起来，放在单独的数据库里，其中最近一段时间的数据会同步到另一个数据库做成热数据，用来查询分析。
* 数据库日志，这个不太熟，SQL Server和MySQL的数据库是一个单独的文件，数据库系统可以设置成定期备份到别的地方。

# 不同类型的日志

## 调试日志，`printf`大法

这个一般都是在不方便debug的时候会用上，一般说来主要是下面几个方面：

1. 这种日志前后会打出来明显的分割线，在大批的日志中可以快速找到你要看的数据。
2. 一般要写代码来serialize数据成方便看的格式来，比如内存block按字节打印成十六进制
3. 单个数据一般不会导致意外情况，所以很多时候需要在程序的很多地方加这种日志来帮助调试。时间长了就能积累出一批常用的数据打印输出函数/方法，可以注意收集。
4. 日志写到stdout或者stderr有可能不是马上能看到的，个别时候需要自己手动flush。

这个地方最大的坑在于多线程的情况下有时候会因为日志打印或者日志数据生成而导致bug不能重现，比如在调试kernel的时候。这种时候只能靠设置一些寄存器或者控制中断发声来尝试定位问题。

## Telemetry

这种日志一般不在乎用户是谁，要的是统计数据，比如某个用户X什么时间点了哪个按钮，然后又干了啥，最后进入了程序的一个功能；某请求通过front end到达了某个microservice，完成了一个PUT请求，得到一个可以用来查询状态的URL，用时xxx毫秒，等等。最后过一段时间拿来分析哪个功能被用了多少次，SLA多少，达到目标SLA的访问占总访问量的百分之多少，Latency的状态，等等。这些数据拿来评价一个服务或者一组服务的质量，以及用来决定后面功能和bugfix的优先级。

这个东西的设计和实现主要是想办法提高查询和分析端的效率，比如尽可能把数据分拆到不同的列，而不是啥都写在一个列里面，然后靠字符串匹配来获得信息。这两者的耗时差距在百万级别的日志条数时对热数据的分析就能能差出几分钟。

## 程序行为日志

这个是最常见的日志，也是最容易出问题的日志类型。这个日志的根本目的就是为了分析线上问题的，所以一切设计实现都是以此为出发点的。

1. 必须对每一个网络请求有一个单独的id，对每一个用户的行为有一个单独的id等等。这样才能查询出感兴趣的全部日志
2. 日志得有精确的时间戳，不然没法知道事情发生的经过。
3. 如果涉及多个线程或并发行为，还得记录线程号或者类似的编号。
4. 日志内容一般都得分级别，常见的TRACE, DEBUG, INFO, WARNING, ERROR, FATAL。不用都有，只要分清楚就好。另外就是一定要让项目组里的人统一认识，不然我心里的WARNING跟你心里的ERROR是一样的，那这日志的级别就没有意义了。
5. 导致程序出问题的是一组特殊的数据，使得程序走进了一个意料之外的分支结构。所以如果想从日志里看出问题，只记录函数的调用关系通常是不够的，在避免记录用户隐私的情况下，尽量记录出问题时面对的数据。
6. 日志的格式见仁见智，一般有现成框架的就别纠结直接上吧。没有的话就项目组自己制定一个，统一意见之后就可以用了。这里需要注意的是如果采用了类似DrWatson的二进制日志，得存好了对应版本的symbol，不然拿到二进制的log找不到symbol那就抓瞎了。当然，还得对上版本，所以二进制日志的里面得包含版本号，帮助你找到对应的symbol。天下没有免费的午餐。

这方面见到过的坑实在太多，我印象深刻的有下面几个：

1. DEBUG日志里面包含了产品代码，比如`log.debug("I'm here %s", foo.func());`结果当DEBUG日志被禁止之后，产品代码`foo.func()`也被拿掉了，于是产品出了问题，而程序员用开了DEBUG日志的build去重现的时候发现一切正常。
2. 在嵌入式设备上，一个`for`循环里面输出一个长度不固定字符串。结果没想到在某些情况下这个`for`循环执行了上万次，而字符串都特长，然后日志直接把存储空间撑爆了。
3. 日志里面包含了用户的敏感信息，被公司专门的代码审查抓到，还好不是被用户告了。火速拿掉这段代码。
4. 调试Linux kernel启动过程中的异常行为，加一行log就怎么都不能重现，去掉了就每次重现，最后用PC喇叭的叫声定位修复了问题。

以上每一点都能深入写更多的内容，鉴于这个只是个综述性的文章，就不展开了。

# 参考文献

1. [The Art of Logging](https://musigma.blog/2017/11/06/logging.html)
2. [Distributed systems, chapter 3 Time and order](http://book.mixu.net/distsys/time.html)
3. [Log file](https://en.wikipedia.org/wiki/Log_file)
4. [syslog](https://en.wikipedia.org/wiki/Syslog)